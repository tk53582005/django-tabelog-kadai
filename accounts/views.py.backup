from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib import messages
from django.views.generic import TemplateView, UpdateView
from django.urls import reverse_lazy, reverse
from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.forms import PasswordChangeForm
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from django.conf import settings
from django.utils.decorators import method_decorator
from django.utils import timezone
import stripe
import json
import logging
from datetime import datetime, timedelta
from .models import CustomUser, Subscription, PaymentHistory, StripeWebhookLog
from .forms import UserProfileForm

# Stripe設定
stripe.api_key = settings.STRIPE_SECRET_KEY
logger = logging.getLogger(__name__)


class MyPageView(LoginRequiredMixin, TemplateView):
    template_name = 'accounts/mypage.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        
        # お気に入り店舗を取得
        from restaurants.models import Favorite, Review, Reservation
        context['favorite_restaurants'] = Favorite.objects.filter(user=user).select_related('restaurant')[:5]
        
        # 最近のレビューを取得
        context['recent_reviews'] = Review.objects.filter(user=user).select_related('restaurant').order_by('-created_at')[:5]
        
        # プレミアム会員の場合、予約履歴も取得
        if user.is_premium:
            context['recent_reservations'] = Reservation.objects.filter(user=user).select_related('restaurant').order_by('-created_at')[:5]
        
        # サブスクリプション情報を取得
        if user.is_premium:
            subscription = user.get_subscription()
            context['subscription'] = subscription
            if subscription:
                context['days_until_renewal'] = subscription.days_until_renewal
                
                # 支払い方法情報を取得
                if user.stripe_customer_id:
                    try:
                        payment_methods = stripe.PaymentMethod.list(
                            customer=user.stripe_customer_id,
                            type="card"
                        )
                        if payment_methods.data:
                            context['payment_method'] = payment_methods.data[0]
                    except stripe.error.StripeError as e:
                        logger.error(f"Failed to retrieve payment methods: {e}")
        
        # 決済履歴を取得
        context['payment_history'] = PaymentHistory.objects.filter(user=user).order_by('-created_at')[:5]
        
        return context


class ProfileEditView(LoginRequiredMixin, UpdateView):
    model = CustomUser
    form_class = UserProfileForm
    template_name = 'accounts/profile_edit.html'
    success_url = reverse_lazy('accounts:mypage')
    
    def get_object(self):
        return self.request.user
    
    def form_valid(self, form):
        messages.success(self.request, 'プロフィールを更新しました。')
        return super().form_valid(form)


@login_required
def password_change_view(request):
    if request.method == 'POST':
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            user = form.save()
            update_session_auth_hash(request, user)
            messages.success(request, 'パスワードを変更しました。')
            return redirect('accounts:mypage')
    else:
        form = PasswordChangeForm(request.user)
    
    return render(request, 'accounts/password_change.html', {'form': form})


# ===== カード管理機能 =====

class CardManageView(LoginRequiredMixin, TemplateView):
    """クレジットカード管理ページ"""
    template_name = 'accounts/card_manage.html'
    
    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_premium:
            messages.error(request, 'プレミアム会員のみ利用可能です。')
            return redirect('accounts:mypage')
        return super().dispatch(request, *args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        
        try:
            if user.stripe_customer_id:
                # 支払い方法一覧を取得
                payment_methods = stripe.PaymentMethod.list(
                    customer=user.stripe_customer_id,
                    type="card"
                )
                context['payment_methods'] = payment_methods.data
                
                # デフォルトの支払い方法を取得
                customer = stripe.Customer.retrieve(user.stripe_customer_id)
                context['default_payment_method'] = customer.invoice_settings.default_payment_method
                
        except stripe.error.StripeError as e:
            logger.error(f"Failed to retrieve payment methods: {e}")
            messages.error(self.request, 'カード情報の取得に失敗しました。')
        
        return context


class CardAddView(LoginRequiredMixin, TemplateView):
    """新しいクレジットカード追加ページ"""
    template_name = 'accounts/card_add.html'
    
    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_premium:
            messages.error(request, 'プレミアム会員のみ利用可能です。')
            return redirect('accounts:mypage')
        return super().dispatch(request, *args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['stripe_public_key'] = settings.STRIPE_PUBLIC_KEY
        return context
    
    def post(self, request, *args, **kwargs):
        try:
            payment_method_id = request.POST.get('payment_method_id')
            user = request.user
            
            if not payment_method_id:
                messages.error(request, 'カード情報が正しく送信されませんでした。')
                return self.get(request, *args, **kwargs)
            
            # Stripe顧客がない場合は作成
            if not user.stripe_customer_id:
                customer = stripe.Customer.create(
                    email=user.email,
                    metadata={'user_id': user.id}
                )
                user.stripe_customer_id = customer.id
                user.save()
            
            # 支払い方法を顧客にアタッチ
            stripe.PaymentMethod.attach(
                payment_method_id,
                customer=user.stripe_customer_id,
            )
            
            # デフォルトの支払い方法として設定
            stripe.Customer.modify(
                user.stripe_customer_id,
                invoice_settings={
                    'default_payment_method': payment_method_id,
                },
            )
            
            messages.success(request, 'カードを追加しました。')
            return redirect('accounts:card_manage')
            
        except stripe.error.StripeError as e:
            logger.error(f"Failed to add payment method: {e}")
            messages.error(request, f'カードの追加に失敗しました: {str(e)}')
            return self.get(request, *args, **kwargs)


class CardChangeView(LoginRequiredMixin, TemplateView):
    """クレジットカード変更ページ"""
    template_name = 'accounts/card_change.html'
    
    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_premium:
            messages.error(request, 'プレミアム会員のみ利用可能です。')
            return redirect('accounts:mypage')
        return super().dispatch(request, *args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['stripe_public_key'] = settings.STRIPE_PUBLIC_KEY
        
        user = self.request.user
        try:
            if user.stripe_customer_id:
                # 現在の支払い方法を取得
                payment_methods = stripe.PaymentMethod.list(
                    customer=user.stripe_customer_id,
                    type="card"
                )
                if payment_methods.data:
                    context['current_payment_method'] = payment_methods.data[0]
                    
        except stripe.error.StripeError as e:
            logger.error(f"Failed to retrieve current payment method: {e}")
        
        return context
    
    def post(self, request, *args, **kwargs):
        try:
            payment_method_id = request.POST.get('payment_method_id')
            old_payment_method_id = request.POST.get('old_payment_method_id')
            user = request.user
            
            if not payment_method_id:
                messages.error(request, 'カード情報が正しく送信されませんでした。')
                return self.get(request, *args, **kwargs)
            
            # 新しい支払い方法を顧客にアタッチ
            stripe.PaymentMethod.attach(
                payment_method_id,
                customer=user.stripe_customer_id,
            )
            
            # デフォルトの支払い方法として設定
            stripe.Customer.modify(
                user.stripe_customer_id,
                invoice_settings={
                    'default_payment_method': payment_method_id,
                },
            )
            
            # 古い支払い方法を削除
            if old_payment_method_id:
                try:
                    stripe.PaymentMethod.detach(old_payment_method_id)
                except stripe.error.StripeError as e:
                    logger.warning(f"Failed to detach old payment method: {e}")
            
            messages.success(request, 'カード情報を変更しました。')
            return redirect('accounts:card_manage')
            
        except stripe.error.StripeError as e:
            logger.error(f"Failed to change payment method: {e}")
            messages.error(request, f'カードの変更に失敗しました: {str(e)}')
            return self.get(request, *args, **kwargs)


@login_required
@require_POST
def set_default_card(request):
    """デフォルトの支払い方法を設定"""
    try:
        payment_method_id = request.POST.get('payment_method_id')
        user = request.user
        
        if not payment_method_id:
            return JsonResponse({'error': '支払い方法IDが必要です'}, status=400)
        
        if not user.stripe_customer_id:
            return JsonResponse({'error': 'カスタマーIDが設定されていません'}, status=400)
        
        # デフォルトの支払い方法として設定
        stripe.Customer.modify(
            user.stripe_customer_id,
            invoice_settings={
                'default_payment_method': payment_method_id,
            },
        )
        
        return JsonResponse({'success': True, 'message': 'メインカードを設定しました'})
        
    except stripe.error.StripeError as e:
        logger.error(f"Failed to set default payment method: {e}")
        return JsonResponse({'error': str(e)}, status=400)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return JsonResponse({'error': '予期しないエラーが発生しました'}, status=500)


@login_required
@require_POST
def remove_payment_method(request):
    """支払い方法の削除"""
    try:
        payment_method_id = request.POST.get('payment_method_id')
        user = request.user
        
        if not payment_method_id:
            return JsonResponse({'error': '支払い方法IDが必要です'}, status=400)
        
        # 支払い方法をデタッチ
        stripe.PaymentMethod.detach(payment_method_id)
        
        return JsonResponse({'success': True, 'message': 'カードを削除しました'})
        
    except stripe.error.StripeError as e:
        logger.error(f"Failed to remove payment method: {e}")
        return JsonResponse({'error': str(e)}, status=400)


@login_required
def billing_portal(request):
    """Stripe請求ポータルにリダイレクト"""
    try:
        user = request.user
        
        if not user.stripe_customer_id:
            messages.error(request, 'カスタマーIDが設定されていません。')
            return redirect('accounts:mypage')
        
        # 請求ポータルセッションを作成
        session = stripe.billing_portal.Session.create(
            customer=user.stripe_customer_id,
            return_url=request.build_absolute_uri(reverse('accounts:mypage'))
        )
        
        return redirect(session.url)
        
    except stripe.error.StripeError as e:
        logger.error(f"Failed to create billing portal session: {e}")
        messages.error(request, '請求ポータルへのアクセスに失敗しました。')
        return redirect('accounts:mypage')


# ===== Stripe決済システム =====

class SubscriptionPlanView(LoginRequiredMixin, TemplateView):
    """サブスクリプションプラン表示"""
    template_name = 'accounts/subscription_plan.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['subscription_settings'] = settings.SUBSCRIPTION_SETTINGS
        context['stripe_public_key'] = settings.STRIPE_PUBLIC_KEY
        
        # 既にプレミアム会員の場合は現在のサブスクリプション情報を追加
        if self.request.user.is_premium:
            context['current_subscription'] = self.request.user.get_subscription()
        
        return context


@login_required
def create_checkout_session(request):
    """Stripe Checkout セッション作成"""
    if request.method != 'POST':
        return JsonResponse({'error': 'POST method required'}, status=400)
    
    try:
        user = request.user
        
        # 既にプレミアム会員の場合は処理を停止
        if user.is_premium:
            return JsonResponse({'error': '既にプレミアム会員です'}, status=400)
        
        # Stripe顧客を作成または取得
        if user.stripe_customer_id:
            customer_id = user.stripe_customer_id
        else:
            customer = stripe.Customer.create(
                email=user.email,
                metadata={'user_id': user.id}
            )
            customer_id = customer.id
            user.stripe_customer_id = customer_id
            user.save()
        
        # Checkout セッションを作成
        checkout_session = stripe.checkout.Session.create(
            customer=customer_id,
            payment_method_types=['card'],
            mode='subscription',
            line_items=[{
                'price': settings.STRIPE_PRICE_ID_PREMIUM,
                'quantity': 1,
            }],
            success_url=request.build_absolute_uri(reverse('accounts:payment_success')) + '?session_id={CHECKOUT_SESSION_ID}',
            cancel_url=request.build_absolute_uri(reverse('accounts:payment_cancel')),
            metadata={
                'user_id': user.id,
            }
        )
        
        logger.info(f"Checkout session created for user {user.id}: {checkout_session.id}")
        
        return JsonResponse({'checkout_url': checkout_session.url})
    
    except stripe.error.StripeError as e:
        logger.error(f"Stripe error: {e}")
        return JsonResponse({'error': str(e)}, status=400)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return JsonResponse({'error': '予期しないエラーが発生しました'}, status=500)


class PaymentSuccessView(LoginRequiredMixin, TemplateView):
    """決済成功ページ"""
    template_name = 'accounts/payment_success.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        session_id = self.request.GET.get('session_id')
        
        if session_id:
            try:
                # Checkoutセッションの詳細を取得
                session = stripe.checkout.Session.retrieve(session_id)
                context['session'] = session
                
                # サブスクリプション情報を取得
                if session.subscription:
                    subscription = stripe.Subscription.retrieve(session.subscription)
                    context['subscription'] = subscription
                    
            except stripe.error.StripeError as e:
                logger.error(f"Failed to retrieve session {session_id}: {e}")
                messages.error(self.request, '決済情報の取得に失敗しました。')
        
        return context


class PaymentCancelView(LoginRequiredMixin, TemplateView):
    """決済キャンセルページ"""
    template_name = 'accounts/payment_cancel.html'


class SubscriptionManageView(LoginRequiredMixin, TemplateView):
    """サブスクリプション管理ページ"""
    template_name = 'accounts/subscription_manage.html'
    
    def dispatch(self, request, *args, **kwargs):
        # プレミアム会員のみアクセス可能
        if not request.user.is_premium:
            messages.error(request, 'プレミアム会員のみアクセス可能です。')
            return redirect('accounts:subscription_plan')
        return super().dispatch(request, *args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        
        # サブスクリプション情報
        subscription = user.get_subscription()
        context['subscription'] = subscription
        
        # 決済履歴
        context['payment_history'] = PaymentHistory.objects.filter(user=user).order_by('-created_at')
        
        return context


@login_required
@require_POST
def cancel_subscription(request):
    """サブスクリプションキャンセル"""
    try:
        user = request.user
        subscription = user.get_subscription()
        
        if not subscription:
            return JsonResponse({'error': 'アクティブなサブスクリプションがありません'}, status=400)
        
        # Stripeでサブスクリプションをキャンセル
        stripe.Subscription.modify(
            subscription.stripe_subscription_id,
            cancel_at_period_end=True
        )
        
        logger.info(f"Subscription {subscription.stripe_subscription_id} marked for cancellation")
        messages.success(request, 'サブスクリプションのキャンセルを受け付けました。現在の期間終了時に停止されます。')
        
        return JsonResponse({'success': True})
    
    except stripe.error.StripeError as e:
        logger.error(f"Stripe error during cancellation: {e}")
        return JsonResponse({'error': str(e)}, status=400)
    except Exception as e:
        logger.error(f"Unexpected error during cancellation: {e}")
        return JsonResponse({'error': '予期しないエラーが発生しました'}, status=500)


@csrf_exempt
def stripe_webhook(request):
    """Stripe WebHook処理"""
    payload = request.body
    sig_header = request.META.get('HTTP_STRIPE_SIGNATURE')
    endpoint_secret = settings.STRIPE_WEBHOOK_SECRET
    
    try:
        # WebHookの署名を検証
        event = stripe.Webhook.construct_event(
            payload, sig_header, endpoint_secret
        )
    except ValueError as e:
        logger.error(f"Invalid payload: {e}")
        return HttpResponse(status=400)
    except stripe.error.SignatureVerificationError as e:
        logger.error(f"Invalid signature: {e}")
        return HttpResponse(status=400)
    
    # WebHookログを記録
    webhook_log, created = StripeWebhookLog.objects.get_or_create(
        stripe_event_id=event['id'],
        defaults={
            'event_type': event['type'],
            'processed': False
        }
    )
    
    if not created and webhook_log.processed:
        # 既に処理済みの場合はスキップ
        return HttpResponse(status=200)
    
    try:
        # イベントタイプに応じた処理
        if event['type'] == 'customer.subscription.created':
            handle_subscription_created(event['data']['object'])
        elif event['type'] == 'customer.subscription.updated':
            handle_subscription_updated(event['data']['object'])
        elif event['type'] == 'customer.subscription.deleted':
            handle_subscription_deleted(event['data']['object'])
        elif event['type'] == 'invoice.payment_succeeded':
            handle_payment_succeeded(event['data']['object'])
        elif event['type'] == 'invoice.payment_failed':
            handle_payment_failed(event['data']['object'])
        
        # 処理完了をマーク
        webhook_log.processed = True
        webhook_log.save()
        
        logger.info(f"Webhook {event['id']} processed successfully")
        
    except Exception as e:
        logger.error(f"Error processing webhook {event['id']}: {e}")
        webhook_log.error_message = str(e)
        webhook_log.save()
        return HttpResponse(status=500)
    
    return HttpResponse(status=200)


def handle_subscription_created(subscription_data):
    """サブスクリプション作成時の処理"""
    try:
        # 顧客情報から用ユーザーを特定
        customer = stripe.Customer.retrieve(subscription_data['customer'])
        user = CustomUser.objects.get(stripe_customer_id=customer.id)
        
        # サブスクリプションを作成
        Subscription.objects.create(
            user=user,
            stripe_subscription_id=subscription_data['id'],
            stripe_customer_id=customer.id,
            stripe_price_id=subscription_data['items']['data'][0]['price']['id'],
            status=subscription_data['status'],
            current_period_start=datetime.fromtimestamp(subscription_data['current_period_start'], tz=timezone.utc),
            current_period_end=datetime.fromtimestamp(subscription_data['current_period_end'], tz=timezone.utc),
        )
        
        logger.info(f"Subscription created for user {user.id}")
        
    except CustomUser.DoesNotExist:
        logger.error(f"User not found for customer {subscription_data['customer']}")
    except Exception as e:
        logger.error(f"Error creating subscription: {e}")
        raise


def handle_subscription_updated(subscription_data):
    """サブスクリプション更新時の処理"""
    try:
        subscription = Subscription.objects.get(
            stripe_subscription_id=subscription_data['id']
        )
        
        # ステータスと期間を更新
        subscription.status = subscription_data['status']
        subscription.current_period_start = datetime.fromtimestamp(subscription_data['current_period_start'], tz=timezone.utc)
        subscription.current_period_end = datetime.fromtimestamp(subscription_data['current_period_end'], tz=timezone.utc)
        subscription.save()
        
        logger.info(f"Subscription {subscription.id} updated")
        
    except Subscription.DoesNotExist:
        logger.error(f"Subscription not found: {subscription_data['id']}")
    except Exception as e:
        logger.error(f"Error updating subscription: {e}")
        raise


def handle_subscription_deleted(subscription_data):
    """サブスクリプション削除時の処理"""
    try:
        subscription = Subscription.objects.get(
            stripe_subscription_id=subscription_data['id']
        )
        
        subscription.status = 'canceled'
        subscription.save()
        
        logger.info(f"Subscription {subscription.id} canceled")
        
    except Subscription.DoesNotExist:
        logger.error(f"Subscription not found: {subscription_data['id']}")
    except Exception as e:
        logger.error(f"Error canceling subscription: {e}")
        raise


def handle_payment_succeeded(invoice_data):
    """決済成功時の処理"""
    try:
        # サブスクリプションを特定
        subscription = Subscription.objects.get(
            stripe_subscription_id=invoice_data['subscription']
        )
        
        # 決済履歴を作成
        PaymentHistory.objects.create(
            user=subscription.user,
            subscription=subscription,
            stripe_payment_intent_id=invoice_data['payment_intent'],
            stripe_invoice_id=invoice_data['id'],
            amount=invoice_data['amount_paid'] / 100,  # セントから円に変換
            currency=invoice_data['currency'],
            status='succeeded',
            description=f"プレミアム会員 月額料金",
            paid_at=datetime.fromtimestamp(invoice_data['status_transitions']['paid_at'], tz=timezone.utc),
        )
        
        logger.info(f"Payment recorded for user {subscription.user.id}")
        
    except Subscription.DoesNotExist:
        logger.error(f"Subscription not found for invoice {invoice_data['id']}")
    except Exception as e:
        logger.error(f"Error recording payment: {e}")
        raise


def handle_payment_failed(invoice_data):
    """決済失敗時の処理"""
    try:
        subscription = Subscription.objects.get(
            stripe_subscription_id=invoice_data['subscription']
        )
        
        # 失敗した決済履歴を作成
        PaymentHistory.objects.create(
            user=subscription.user,
            subscription=subscription,
            stripe_payment_intent_id=invoice_data.get('payment_intent', ''),
            stripe_invoice_id=invoice_data['id'],
            amount=invoice_data['amount_due'] / 100,
            currency=invoice_data['currency'],
            status='failed',
            description=f"プレミアム会員 月額料金（決済失敗）",
            failure_reason=invoice_data.get('last_finalization_error', {}).get('message', '不明なエラー'),
        )
        
        logger.warning(f"Payment failed for user {subscription.user.id}")
        
    except Subscription.DoesNotExist:
        logger.error(f"Subscription not found for failed invoice {invoice_data['id']}")
    except Exception as e:
        logger.error(f"Error recording failed payment: {e}")
        raise